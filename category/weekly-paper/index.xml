<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Weekly Paper | Welcome to Guangba&#39;s HomePage</title>
    <link>https://yuxiaoba.github.io/category/weekly-paper/</link>
      <atom:link href="https://yuxiaoba.github.io/category/weekly-paper/index.xml" rel="self" type="application/rss+xml" />
    <description>Weekly Paper</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sat, 04 Feb 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://yuxiaoba.github.io/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>Weekly Paper</title>
      <link>https://yuxiaoba.github.io/category/weekly-paper/</link>
    </image>
    
    <item>
      <title>基于 Trace 的根因定位（二）： Spectrum-Based Fault Localization  算法</title>
      <link>https://yuxiaoba.github.io/post/trace_based_rca_2/</link>
      <pubDate>Sat, 04 Feb 2023 00:00:00 +0000</pubDate>
      <guid>https://yuxiaoba.github.io/post/trace_based_rca_2/</guid>
      <description>&lt;p&gt;今日立春，东风吹散梅梢雪，一夜挽回天下春。&lt;/p&gt;
&lt;p&gt;之前我在 基于 Traces 的根因定位（一）：Trace 的演进之路 简单地介绍了 Trace 的出现及其演进的过程。下面我将总结第一种基于 Trace 的根因定位算法：基于 Spectrum-Based Fault Localization（SFL，基于程序频谱的故障定位）算法的 Trace 根因定位算法。​&lt;/p&gt;
&lt;p&gt;首先我们介绍一下什么是 SFL ？&lt;/p&gt;
&lt;p&gt;SFL 是软件测试领域定位故障常用的一种方法。该方法通过测试用例对被测函数（代码实体）的覆盖情况以及测试用例成功或失败来对潜在的代码错误进行定位。&lt;/p&gt;
&lt;p&gt;具体地，对于某个函数 𝑓 ， 𝑒𝑝 为覆盖了该函数并成功运行的测试用例的数量， 𝑒𝑓 为覆盖了该函数但运行失败测试用例的数量， 𝑛𝑝 为未覆盖该函数并成功运行的测试用例的数量， 𝑛𝑓 为未覆盖该函数并运行失败测试用例的数量。最后通过一些数学公式，利用这四个原始统计量计算各个函数的得分。&lt;/p&gt;
&lt;p&gt;如下图是一个由 3 个被测函数和 4 个测试用例的示意图，其中函数 m2 存在代码错误，而且是条件触发的，所有标红的函数和测试用例都出现了错误。下表中给出了不同函数的 SFL 原始统计量的取值。&lt;/p&gt;
&lt;h2 id=&#34;center-font-color0080001fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;01&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50002_dsn_pinpoint-problem-determination-in-large-dynamic-internet-servicesfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;02_DSN_Pinpoint: Problem Determination in Large, Dynamic Internet Services&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./pinpoint.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 典型的 Internet 服务有许多分为多个层的组件：Frontend、WebServer 和 Database，每个层中的许多（复制的）子组件。当客户端连接到这些服务时，它们的请求将通过该系统动态路由到子组件。为了捕获这些动态的请求路径，Pinpoint 设计了一种记录每个请求经过组件的数据格式，用于帮助工程师分析根因。&lt;/p&gt;
&lt;p&gt;Pinpoint 为每个组件（Component）生成唯一的 Component ID 用于标记组件，为每个 HTTP 请求生成唯一的标识 Request ID 标记请求。在请求执行中 Request ID 通过线程局部变量（ThreadLocal）传递到下游组件，每次调用到一个组件，就使用 (Request ID , Component ID) 组合记录一个 Trace Log。除此之外，Pinpoint 还实时检测请求是否成功，并利用 Failure 字段对请求的成功和失败进行标记。 最后汇总 Trace Log 可获得下表所示的 Trace 数据。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./pinpoint2.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文发表于 2002 年的 CCF B 类会议 DSN，是我看到的第一篇生成唯一的 Request ID，并进行全链路传播的论文，为以后 Trace 的实现提供了思路。但在传统的三层架构的服务架构下，Span 之间的父子关系是比较简单的，论文还未考虑复杂的 Parent-Child Span 的构建。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://ieeexplore.ieee.org/document/1029005&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://ieeexplore.ieee.org/document/1029005&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080002fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;02&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50007_nsdi_x-trace-a-pervasive-network-tracing-frameworkfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;07_NSDI_X-Trace: A Pervasive Network Tracing Framework&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./xtrace.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 现代 Internet 系统通常结合不同的应用程序，并且跨越不同的网络管理域。为了构建在分布式集群的网络链路，X-Trace 论文延续并扩展了 Pinpoint 论文的思路，提出了能够重新构建完整 Trace 的框架。&lt;/p&gt;
&lt;p&gt;X-Trace 的调用链追踪方案是对 Poinpont 思路的扩展，它将 Trace 的 Meta Data 写入到 message 中 (例如，写入到 HTTP 请求的拓展头上)，并沿着请求传播到经过的每个设备上。 与 Poinpont 相比，如下图所示 X-Trace 的 Meta Data 扩展了更多的元素，引入了 Span ID 和 Colletor 地址的概念。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./xtrace2.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此外，X-Trace 还设计了一个Trace Collector 的框架，将 Trace 的生成与采集解耦。X-Trace 在本地启动一个开放一个 UDP 协议端口的守护进程，应用可以将 Trace 发送到守护进程，并放入到一个队列中，队列的另外一边则将 Trace 发送到缓存或者持久化的数据库中。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./xtrace3.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; X-Trace 发表于 2007 年的 CCF A 类会议 NSDI，论文对 Trace 的 Meta Data 的定义已经初具雏形，Trace Collector 的架构也深深地影响了现今的 Opentelemetry Collector, Jeager Agent 等 Trace Collector。但 X-Trace  还主要注重于 Trace 结构的构建，对时间的开销是忽视的，不能很好地诊断性能问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://www.usenix.org/conference/nsdi-07/x-trace-pervasive-network-tracing-framework&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.usenix.org/conference/nsdi-07/x-trace-pervasive-network-tracing-framework&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080003fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;03&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50010_google_dapper-a-large-scale-distributed-systems-tracing-infrastructurefontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;10_Google_Dapper, a Large-Scale Distributed Systems Tracing Infrastructure&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./dapper.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;CloudWeekly 每周分享与云计算相关论文，相关的论文集被收纳到 github 仓库 &lt;a href=&#34;https://github.com/IntelligentDDS/awesome-papers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/IntelligentDDS/awesome-papers&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SoCC 2022 论文集合（二)</title>
      <link>https://yuxiaoba.github.io/post/socc_2/</link>
      <pubDate>Wed, 04 Jan 2023 00:00:00 +0000</pubDate>
      <guid>https://yuxiaoba.github.io/post/socc_2/</guid>
      <description>&lt;p&gt;今日小寒，小寒纪节欣相遇，瑞兆占年定可期。&lt;/p&gt;
&lt;p&gt;ACM Symposium on Cloud Computing 是 Cloud Computing 领域的顶级会议。SoCC 虽然是一个 CCF B 会议，但它是我最喜欢的计算机会议，而且我觉得 SoCC 的 Paper 是有 A 类会议实力的。很遗憾它这次没有像 Eurosys 一样增补为 A 类会议。&lt;/p&gt;
&lt;p&gt;SoCC 2022 会议共收到 155 份投稿，录用了 38 篇，录用率 24.5% 。作为 SoCC 的忠实粉丝，当然我也投了，当然我也是分母。之前我分享和推荐了部分 SoCC 2022上我很感兴趣的论文 &lt;a href=&#34;https://yuxiaoba.github.io/post/socc_1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SoCC 2022 论文集合（一）&lt;/a&gt;，这一次我们继续介绍两篇 SoCC 2022 上的 Paper。&lt;/p&gt;
&lt;h2 id=&#34;center-font-color0080001fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;01&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50022_socc_deepscaling-microservices-autoscaling-for-stable-cpu-utilization-in-large-scale-cloud-systemsfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;22_SoCC_DeepScaling: Microservices AutoScaling for Stable CPU Utilization in Large Scale Cloud Systems&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./deepscaling1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt;  为了在保障服务 SLO 的前提下，使系统的 CPU 利用率最大化从而减少资源的消耗，蚂蚁金服提出了一个名为 DeepScaling 的微服务自动伸缩框架。DeepScaling 将微服务自动伸缩3个模块：流量预测模型（Workload Forecaster），CPU估计模型（CPU Utilization Estimator）以及容量决策模型（Scaling Decider）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DeepScaling使用 Spatio-temporal Graph Neural Network 预测每个微服务的 Workload&lt;/li&gt;
&lt;li&gt;DeepScaling通过使用 Deep Neural Network, 将工作负载强度（包括RPC请求、文件I/O、DB 访问、消息请求、HTTP请求，以及特定的辅助特征如实例数、服务ID、时间戳等）映射到估计的 CPU 利用率来估计 CPU 利用率&lt;/li&gt;
&lt;li&gt;DeepScaling 基于改进的 DQN 强化学习算法为每个服务生成自动缩放策略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./deepscaling2.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; DeepScaling 与 &lt;a href=&#34;https://yuxiaoba.github.io/post/socc_1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SoCC 2022 论文集合（一）&lt;/a&gt; 中的叶可江老师的 paper 的思路是类似的。DeepScaling 在蚂蚁集团拥有135个微服务的真实生产环境中部署，平均每天可节省3 W多个CPU内核, 6W 多GB的内存。虽然 DeepScaling 被小范围应用，但是我个人感觉如果工作负载预测准了，后面应该无需加上这么复杂的服务实例决策方法，也没有必要使用黑盒的方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://dl.acm.org/doi/pdf/10.1145/3542929.3563469&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dl.acm.org/doi/pdf/10.1145/3542929.3563469&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080002fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;02&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50022_socc_method-overloading-the-circuitfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;22_SoCC_Method Overloading the Circuit&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./circuit.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; Circuit Breaker (中文被翻译成熔断或者断路器) 机制是应对雪崩效应的一种微服务容错机制。当链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。&lt;/p&gt;
&lt;p&gt;论文研究了两个来自大型食品配送平台 DoorDash 的 Circuit Breaker 工业使用案例。论文发现，现有的 Circuit Breaker 设计不仅不足以容错，而且还发现了应用程序代码中的小变化会对 Circuit Breaker 的工作方式有很大的改变。为了解决这些缺陷，论文提出了两种新的  Circuit Breaker 设计：Path-sensitivity 和 Context-Sensitivity 的 Circuit Breaker，并设想了它们的实现方式。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./circuit1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文的角度很新奇，从 Circuit Breaker 的角度出发，是之前很少学术论文考虑的，比起一些做烂的话题，这个也挺有意思的。这个 CMU 的作者 Christopher Meiklejohn 也是一个牛人，一边创业一边发 Paper, 着实羡慕。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://dl.acm.org/doi/abs/10.1145/3542929.3563466&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dl.acm.org/doi/abs/10.1145/3542929.3563466&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CloudWeekly 每周分享与云计算相关论文，相关的论文集被收纳到 github 仓库 &lt;a href=&#34;https://github.com/IntelligentDDS/awesome-papers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/IntelligentDDS/awesome-papers&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>基于 Metrics 的根因定位 (四)：Meanful Metrics</title>
      <link>https://yuxiaoba.github.io/post/metric_based_rca_4/</link>
      <pubDate>Wed, 21 Dec 2022 00:00:00 +0000</pubDate>
      <guid>https://yuxiaoba.github.io/post/metric_based_rca_4/</guid>
      <description>&lt;p&gt;之前我总结了两种常见的基于 Metric 的根因定位算法 &lt;a href=&#34;https://yuxiaoba.github.io/post/metric_based_rca_1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 Metrics 的根因定位 (一)：故障刻画&lt;/a&gt; 和  &lt;a href=&#34;https://yuxiaoba.github.io/post/metric_based_rca_2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 Metrics 的根因定位 (二)：因果关系图&lt;/a&gt; 。这一次介绍第三种基于 Metric 的根因定位算法: 多维下钻。&lt;/p&gt;
&lt;p&gt;在 SRE 检测到 KPI 发生异常时（如响应成功率下降），还面临一个灵魂拷问：为什么发生异常了？（成功率为什么下降了？），这个时候我们需要增加维的层次，从而可以由粗粒度的数据到细粒度的数据来观察数据。&lt;/p&gt;
&lt;p&gt;例如下表我们发现某服务的当前总的失败请求数目比前一个时间点增加了很多，工程师会进一步挖掘失败请求的属性，比如查看数据中心的元素，发现广州的数据中心存在异常导致的这次故障，这就是一个简单的多维下钻的样例。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;数据中心&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;前一时间点失败请求数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;当前时间失败请求数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;差异&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;广州&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1000&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;990&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;上海&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;北京&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;合计&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;25&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1016&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;991&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;center-font-color0080001fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;01&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50014_nsdi_adtributor-revenue-debugging-in-advertising-systemsfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;14_NSDI_Adtributor: Revenue Debugging in Advertising Systems&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./adtributor.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 论文针对广告营收领域的 revenue debugging问题，将多维根因分析问题分解为多个单维根因分析问题，提出了的 Adtributor 算法，并分别针对量值与率值两类指标进行多维度的根因分析。整体思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;利用 ARMA 模型进行异常检测。根据8周的历史数据，考虑到正常的时间和星期的波动，生成一个基于模型的测量值预测。然后，将实际值与预测值进行比较：当一个测量值的实际值与预测值有明显差异时，将产生一个异常警报。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算每个维度下每个元素的 explanatory power （单个元素预测值与实际值的差异和整个维度预测值与实际值差异的比值，论文公式 4） 与 surprise 值（可直观理解为预测值与实际值变化的程度，论文公式 5），定位出每个维度下的异常元素集合，最后根据每个维度总的 surprise  值大小汇总输出根因集合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./adtributor1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; Microsoft 2014 年发表在 NSDI （CCF A）上的论文，论文可以说是基于 Metrics 的多维下钻分析的开山之作，论文在 Mcirosoft 实际落地，可解释性比较强，后面的多维下钻的工作也大多在其基础之上进行创新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://www.usenix.org/system/files/conference/nsdi14/nsdi14-paper-bhagwan.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.usenix.org/system/files/conference/nsdi14/nsdi14-paper-bhagwan.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080002fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;02&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50016_icse_idice-problem-identification-for-emerging-issuesfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;16_ICSE_iDice: Problem Identification for Emerging Issues&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./idice.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 软件在发布时一般会有很多分类属性（例如版本号，地域，操作平台等），如果发布有异常，用户通过会上报一些反馈的 Issue，此时需要运维工程师能够快速定位究竟是哪些属性造成了 Issue 的上升，提升响应的速度。文章以 Issue 的上升作为告警，通过分析一个时间窗口内 Issue 的属性的组合，找出最有可能导致 Issue 上升的最小属性组合。在搜索空间过大的问题上论文使用了启发式的三个剪枝策略来应对：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Impact based Pruning：一个有用的属性必须引起较大数量变化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change Detection based Pruning: 一个有用的属性组合必须在时间点上符合变化特征&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Isolation Power based Prunning: 合并多余属性组合&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./idice1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; MSRA 林庆维研究员 2016 年发表在 ICSE（CCF A）的论文。论文针对性地处理了用户反馈 Issue 的维度下钻，并在微软落地，剪枝的策略值得学习。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;http://hongyujohn.github.io/iDice.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://hongyujohn.github.io/iDice.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080003fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;03&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50020_ase_impaptr-a-tool-for-identifying-the-clues-to-online-service-anomaliesfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;20_ASE_ImpAPTr: A Tool For Identifying The Clues To Online Service Anomalies&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./impaptr.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 论文是一个广度优先的多维下钻根因定位算法，ImpAPTr，整体思路可分为以下四个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;根据维度组合创建包含根结点和子结点的元素树，如下图所示；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用广度优先遍历算法，删除冗余元素和影响系数 （Impact Factor）相反的元素（论文公式3）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算每个维度组合的贡献度 （Contribution Power，连续两个时间段的影响系数差值，论文公式4）和差异系数 （Diversity Factor， 两个连续时间段内的成功率指标变化程度， 论文公式 5） ；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算每个维度组合 Contribution Power 和 Diversity Factor 的排名之和 ，选取前 n 个维度组合作为成功率下跌的根因线索。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./impaptr1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文是南京大学与美团合作发表在 ASE 2020 上的一篇短文。与 Adtributor  只考虑单个维度不同，ImpAPTr 考虑了多个维度，且构建出维度之间的关系图，通过在图上做广度优先搜索进行根因定位。美团实际落地算法的总结。方法在根因的属性数量不多以及单根因的时候效果应该会比较好。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://dl.acm.org/doi/10.1145/3324884.3415301&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dl.acm.org/doi/10.1145/3324884.3415301&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码链接：&lt;a href=&#34;https://github.com/wanghaoUp/ImpAPTr&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/wanghaoUp/ImpAPTr&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CloudWeekly 每周分享与云计算相关论文，相关的论文集被收纳到 github 仓库 &lt;a href=&#34;https://github.com/IntelligentDDS/awesome-papers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/IntelligentDDS/awesome-papers&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DDS 第一手研究曝光：基于 eBPF 的日志热点约简框架</title>
      <link>https://yuxiaoba.github.io/post/recent_paper2/</link>
      <pubDate>Tue, 20 Dec 2022 00:00:00 +0000</pubDate>
      <guid>https://yuxiaoba.github.io/post/recent_paper2/</guid>
      <description>&lt;p&gt;今日冬至，天时人事日相催，冬至阳生春又来。&lt;/p&gt;
&lt;p&gt;2022 年 5 月我入选了 2022 腾讯犀牛鸟精英人才计划，来到微信的技术架构部的质量平台组做科研实习生。在降本增效的大背景下，我到微信的第一个研究工作是降低海量日志打印和存储的开销。
基于该研究的论文 “ LogReducer: Identify and Reduce Log Hotspots in Kernel on the Fly ” 被软件工程领域顶级国际会议 ICSE 2023 的 Technical Track 录用。论文作者包括中山大学的余广坝、陈鹏飞，腾讯的李派锐、翁天俊、郑海兵，邓月堂。&lt;/p&gt;
&lt;h2 id=&#34;center-font-color008001-研究问题fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;1. 研究问题&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;p&gt;为了协助工程师及时地发现和诊断软件运行时的发生的故障，工程师通常会在程序代码中插入日志语句打印软件运行时的状态。但是，虽然打印大量的运行时日志对定位和解决故障很有帮助，但是日志打印不仅会影响到软件运行的性能，而且造成了很大的持久化负担。在微信，每天的后台日志打印接近 100 万亿行，占用了接近 20 PB 的存储，带来了巨大的运营成本。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./fig1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;为了削减日志的运营成本，我们对微信后台的日志打印和存储的特征进行了分析和挖掘，我们发现「绝大多数的日志开销是由少数的几条日志语句导致的」，我们将这些日志语句称为「日志热点」。这个发现启发我们：「及时发现日志热点，对日志热点的打印进行优化即可降低大量的日志开销」。
例如，微信某个服务的占用存储 Top1 的日志模板占用了该服务 95.7% 的存储，而其他200多个日志模板只占用了剩余 4.3% 的存储，因此如果我们能把 Top1 的这条日志进行优化（如采样或者合并打印）就可以降低大量的开销。&lt;/p&gt;
&lt;p&gt;但是，即便是我们通过分析存储发现了日志热点，想要对其进行及时的处理也不容易。在运营工程师发现某个服务的日志热点并告警给服务对应的开发工程师时，考虑到服务更新上线的计划，开发工程师一般不会立即对日志热点进行优化并上线，通常是等待到服务的下一次更新才进行上线。即便是程序上线后，灰度发布的过程也可能会持续几个小时甚至几天才能更新完服务的所有实例。在这期间，日志热点还是会持续影响程序。
因此我们必须能够在程序运行时对日志热点进行优化。「我们需要一个能够在运行时对日志打印进行针对性拦截和优化的工具，用于缓解发现日志热点到服务上线完成期间的日志开销」。&lt;/p&gt;
&lt;h2 id=&#34;center-font-color008002-日志热点的实证研究fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;2. 日志热点的实证研究&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;p&gt;为了更好地理解日志热点，我们首先对微信的日志热点做了一些实证研究。&lt;/p&gt;
&lt;h3 id=&#34;日志热点定义&#34;&gt;日志热点定义&lt;/h3&gt;
&lt;p&gt;首先我们对日志热点进行定义：假设一个服务 A 在一个时间窗口内占用了S GB 存储， 它包含 n 个日志模板:log1,log2,&amp;hellip;,logn, 这些日志模板分别占据了S1,S2,&amp;hellip;.,Sn GB 的存储 (其中S =S1+S2+&amp;hellip;+Sn)，那么日志热点可以定义为：&lt;/p&gt;
&lt;p&gt;Si/S&amp;gt;ξ,&lt;/p&gt;
&lt;p&gt;这里的 ξ 由工程师制定，我们默认为 0.05。&lt;/p&gt;
&lt;h3 id=&#34;日志热点的普遍性&#34;&gt;日志热点的普遍性&lt;/h3&gt;
&lt;p&gt;我们选取了微信后台日志中存储占用前 20 的服务，对其日志存储进行分析，我们发现日志存储占用前 20 的服务占用了超过 50 % 的存储空间，而其他剩余的 20000 多个服务才占用了 47.2% 的存储空间。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./fig5.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;我们对上述20个服务的所有日志模板进行逐一的分析，我们发现其中有 19个服务至少包含一个日志热点。日志热点的存储总和平均占对应服务存储的 57.86%。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./fig6.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;日志热点在不同的服务中普遍存在。对日志热点进行优化是一个性价比很高的日志约简操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;日志热点对应用性能的影响&#34;&gt;日志热点对应用性能的影响&lt;/h3&gt;
&lt;p&gt;为了分析日志热点对性能的影响，我们对只更新了优化日志热点代码的服务的前后版本性能表现进行对比，我们发现，在相似的工作负载情况下，存在日志热点的版本要比不存在日志热点的版本多消耗 5% 的 CPU （58个核心） 和额外增加 3% 的延迟 （1.8ms）。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./fig7.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;日志热点打印会造成额外的资源消耗（例如，CPU、内存）和性能下降。优化日志热点打印不仅减少了应用程序的资源消耗，还能提高了其性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;日志热点修复的时长&#34;&gt;日志热点修复的时长&lt;/h3&gt;
&lt;p&gt;当我们将日志热点告警给开发工程师后，我们持续跟踪日志打印和工程师优化上线的情况，对日志热点出现到被优化的时间进行了统计。我们发现 97% 的日志热点都是在告警3天以后才得到优化，平均需要超过 9 天。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./fig9.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;同时我们还发现，日志热点的优化并不是一次性的工作，随着程序的迭代，新的日志热点会持续的出现。我们持续观察这 19 个服务三个月，发现 18个服务在优化后再次出现了热点日志。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./fig10.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;日志热点优化通常不能得到及时的响应，且服务会反复出现日志热点。在生产环境中自动检测和运行时动态地修复日志热点是非常重要的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此外我们还对日志热点出现的原因和修复方式进行了调研，详细内容可以看我们的论文。&lt;/p&gt;
&lt;h2 id=&#34;center-font-color008003-logreducer-日志约简框架fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;3. LogReducer 日志约简框架&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;p&gt;对微信这种体量的用户，想要设计一个高效的能够在生产环境中自动检测和运行时动态地修复日志热点的工具是很有挑战的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;「海量的日志规模」：每天需处理上百亿行日志，框架处理日志必须足够高效&lt;/li&gt;
&lt;li&gt;「不影响程序开发」：框架对开发工程师是无感知的，不需对原有代码进行修改或者重编译&lt;/li&gt;
&lt;li&gt;「支持多种编程语言」：框架应该能够支持对多种编程语言的日志打印进行优化&lt;/li&gt;
&lt;li&gt;「不影响服务运行」：框架的执行应该不影响服务的正常运行，不能重启或中断服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传统的日志压缩方法虽然可以缓解日志存储的压力，但是无法消除日志打印对运行时的影响以及日志发送到数据库的开销。在 log agent（例如：filebeat, promtail）中对热点日志进行过滤也是一种解决方式，但是它同样无法消除日志打印对运行时的影响，而且过滤的效率较低。
为了更好的解决上面的挑战，我们提出了一个「基于 eBPF 的日志约简框架：LogReducer」，框架图如下图所示：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./fig11.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;LogReducer 的运行工作流如下所示：&lt;/p&gt;
&lt;p&gt;① LogParser 周期性地从日志数据库中拉取数据，然后基于日志框架中打印的代码位置解析出日志模板，并统计出每个日志模板对应的存储消耗。&lt;/p&gt;
&lt;p&gt;② Hotspot Classifier 根据日志热点定义的公式判定是否存在日志热点。&lt;/p&gt;
&lt;p&gt;③ 如果存在日志热点，Hotspot Classifier 会将日志热点的模板及存储占用信息分别告警离线阶段的程序员和在线阶段的 Log Filter 中。程序员在收到告警后，会根据经验对日志热点进行修复和重新发布。&lt;/p&gt;
&lt;p&gt;④ 在在线阶段，在用户态的 Python Log Filter 会根据告警的日志模板信息，将模板信息 load 进 eBPF Maps 中。在内核态的 eBPF Log Filter 会实时拦截和解析应用程序调用系统调用 Write() 写日志的操作，并在内核态将写入的日志与 eBPF maps 中的日志模板进行匹配，如果匹配成功，则将该次写入丢弃，提前返回日志写入操作，避免日志的用户态和内核态切换，也避免了实际的写入操作。&lt;/p&gt;
&lt;h2 id=&#34;center-font-color008004-实验评估fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;4. 实验评估&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;p&gt;为了评估我们提出的框架，在在线阶段，我们用四种不同的编程语言写了四个日志打印的 benchmark，然后通过控制每秒打印的日志数目测试 LogReducer 的消耗。从下图可以看出，LogReducer 在每个服务实例每秒打印 10 万条日志的时候，也只会给「每个请求增加 500 纳秒」 (一纳秒等于一秒的十亿分之一)的延迟，消耗的 CPU 资源也不到单核的万分之一。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./fig14.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;在离线阶段，我们将告警转发到企业微信并自动拉群，将日志热点的信息转发给服务对应的开发工程师，由开发工程师对日志进行优化。离线阶段的方法在微信实际落地后，将微信每日日志存储量从「20 PB 降低到 12 PB （每日日志存储量降低了40%，每年节省上千万人民币)」。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./fig17.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;以上就是论文的主要内容了，因为最近有点忙，camera-ready 的论文我还没有准备后，后面准备好我会尽快将论文上传到我的个人主页（https://yuxiaoba.github.io）和 Github 的仓库（https://github.com/IntelligentDDS/awesome-papers），欢迎关注我们的工作！。&lt;/p&gt;
&lt;p&gt;最后，非常感谢微信的 Perry, Matt 哥，Tang 哥，还有参与 emparical study 的各位大佬们对论文的支持。第一次离开实验室，来到工业界下山游历，做的还是自己不太擅长的日志分析，说实话是有点慌的，还好一路得到好多人的帮助，也希望后面还会有其他的产出。&lt;/p&gt;
&lt;p&gt;2022 年只剩下 10 天了，本文应该是 2022 年我们的最后一篇推送，感谢大家对我们实验室工作的关注。特殊时期，愿大家各自保重，祝各位身体安康，一起迎接 2023 年的到来！&lt;/p&gt;
&lt;p&gt;CloudWeekly 每周分享与云计算相关论文，相关的论文集被收纳到 github 仓库 &lt;a href=&#34;https://github.com/IntelligentDDS/awesome-papers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/IntelligentDDS/awesome-papers&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SoCC 2022 论文集合（一)</title>
      <link>https://yuxiaoba.github.io/post/socc_1/</link>
      <pubDate>Sun, 20 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://yuxiaoba.github.io/post/socc_1/</guid>
      <description>&lt;p&gt;今日小雪，枫叶欲残看愈好，梅花未动意先香。记得加衣服了～&lt;/p&gt;
&lt;p&gt;ACM Symposium on Cloud Computing 是 Cloud Computing 领域顶级的会议。SoCC 虽然是一个 CCF B 会议，但它是我最喜欢的计算机会议，而且我觉得 SoCC 与 Eurosys 的 Paper 都是有 A 类会议实力的。&lt;/p&gt;
&lt;p&gt;SoCC 2022 上周在旧金山举行，会议共收到 155 份投稿，录用了 38 篇，录用率 24.5% 。作为 SoCC 的忠实粉丝，当然我也投了，当然我也是分母。不过今天还是想要分享和推荐 SoCC 2022 上我很感兴趣的部分论文。&lt;/p&gt;
&lt;h2 id=&#34;center-font-color0080001fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;01&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50022_socc_how-to-fight-production-incidents-an-empirical-study-on-a-large-scale-cloud-servicefontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;22_SoCC_How to Fight Production Incidents? An Empirical Study on a Large-scale Cloud Service&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./incident1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt;  论文从 incident 的生命周期（即 root cause、detection、mitigation ）的角度分析了 Microsoft Team 从 2021 年 5 月到 2022 年 5 月发生的 152 个较为严重的 incident，并对每个阶段之间的相关性进行了详细的分析。回答了以下四个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为什么会发生这些 Incident&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何修复这些 Incident ?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么原因导致检测和修复 Incident 需要较长延迟？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么样的自动化可以帮助服务恢复可用性?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./incident.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./incident2.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文是来自 Microsoft ，获得了今年 SoCC 的 Best paper ! 在 &lt;a href=&#34;https://yuxiaoba.github.io/post/recent_paper1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DDS 第一手研究曝光（一）&lt;/a&gt; 介绍了今年我们在 ISSRE 2022 的分析 Incident 的论文，无独有偶，论文角度几乎一致，但本文作者在企业内部，有更详细的数据，能分析的细节更多。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://dl.acm.org/doi/10.1145/3542929.3563482&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dl.acm.org/doi/10.1145/3542929.3563482&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080002fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;02&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50022_socc_simppo-a-scalable-and-incremental-online-learning-framework-for-serverless-resource-managementfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;22_SoCC_SIMPPO: A Scalable and Incremental Online Learning Framework for Serverless Resource Management&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./simppo1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; Serverless FaaS 被誉为下一代的云计算范式，它提供了尽可能小粒度的资源分配和极致的弹性。但如此细粒度的情况下，在保持高资源利用率的同时管理资源以满足SLO的问题是一个 NP-hard 的问题。论文首先讨论了基于 Single-agent RL 的框架无法感知函数之间的动态资源竞争，会导致延迟不稳定从而违背 SLO。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./simppo2.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;因此， SIMPPO 采用了 Multi-agent RL 框架，它为每个函数配置了一个 Agent 以获得 FaaS 函数的最优资源配置（CPU Limit, Memory Limit, Number Limit）。在训练阶段， SIMPPO 的核心思想是将其他函数和环境的 Multi-agent 视为一个 “Virtual Agent&amp;quot;，将 Multi-agent 转化成为了一个 Two agent 的问题，从而大大加快了强化学习模型收敛的速度。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./simppo3.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文是来自 UIUC 的 Qiu Haoran 博士，也是之前 OSDI 2020 的微服务自动伸缩 FIRM 的作者，也是我的直接竞争者，跟 UIUC 的大佬在这么小的方向撞车真的太难受了。论文在为函数训练模型时是没有考虑函数的参数的，应该来说比较难适应参数变化的问题，也没有考虑函数链的情况。论文还采用了一种两段式的论文写作方式，推荐可以去看看学习学习。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://haoran-qiu.com/pdf/socc22.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://haoran-qiu.com/pdf/socc22.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080003fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;03&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50022_socc_the-power-of-prediction-microservice-auto-scaling-via-workload-learningfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;22_SoCC_The Power of Prediction: Microservice Auto Scaling via Workload Learning&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./madu.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 论文首先基于两个观察：1）单个微服务的 Workload 存在较大的不确定性；2）每个 Container 的 Workload 与 OS-level metrics 存在很强的相关性，提出为每个微服务训练一个自动伸缩的模型来满足 SLO。在离线阶段，论文首先训练出一个融合了 Stochastic Attention 机制的 Seq2Seq 模型对 Workload 进行预测，然后基于  Linear Regression 学习出 CPU 和 Memory 跟 Workload 之间的关系。在线阶段，论文通过预测 Workload 找到可以满足 CPU 和 Memory 的最小服务实例数目，从而执行 Autoscale 。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./madu1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文是去年的 SoCC Best Paper 叶可江老师团队再一次与阿里巴巴合作的基于 Trace 的成果，每年都有一篇 SoCC 可太羡慕了。利用 Trace 精确为每个服务进行 Autoscale 是一直我想做的，思路也是一致的，叶老师做的太快了.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://dl.acm.org/doi/abs/10.1145/3542929.3563477&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dl.acm.org/doi/abs/10.1145/3542929.3563477&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CloudWeekly 每周分享与云计算相关论文，相关的论文集被收纳到 github 仓库 &lt;a href=&#34;https://github.com/IntelligentDDS/awesome-papers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/IntelligentDDS/awesome-papers&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>基于 Trace 的根因定位（一）： Trace 的演进之路</title>
      <link>https://yuxiaoba.github.io/post/trace_based_rca_1/</link>
      <pubDate>Sun, 06 Nov 2022 00:00:00 +0000</pubDate>
      <guid>https://yuxiaoba.github.io/post/trace_based_rca_1/</guid>
      <description>&lt;p&gt;今日立冬，细雨生寒未有霜，庭前木叶半青黄。&lt;/p&gt;
&lt;p&gt;Metrics, Traces, Logs 被誉为可观测性的三大支柱，先前我总结了基于 Metric 的三种根因定位方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://yuxiaoba.github.io/post/metric_based_rca_1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 Metrics 的根因定位 (一)：故障刻画&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yuxiaoba.github.io/post/metric_based_rca_2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 Metrics 的根因定位 (二)：因果关系图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yuxiaoba.github.io/post/metric_based_rca_3/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 Metrics 的根因定位 (三)：多维下钻&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来的几个月里，将继续不定期总结基于 Trace 的根因定位方法。Trace 追踪了请求在应用程序中运行的轨迹，能够完整的串联起请求的上下文关系，在大规模分布式系统根因定位中的作用举足轻重 。在讨论基于 Trace 的根因定位之前，本文先简单介绍 Trace 的出现及其演进的过程。&lt;/p&gt;
&lt;h2 id=&#34;center-font-color0080001fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;01&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50002_dsn_pinpoint-problem-determination-in-large-dynamic-internet-servicesfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;02_DSN_Pinpoint: Problem Determination in Large, Dynamic Internet Services&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./pinpoint.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 典型的 Internet 服务有许多分为多个层的组件：Frontend、WebServer 和 Database，每个层中的许多（复制的）子组件。当客户端连接到这些服务时，它们的请求将通过该系统动态路由到子组件。为了捕获这些动态的请求路径，Pinpoint 设计了一种记录每个请求经过组件的数据格式，用于帮助工程师分析根因。&lt;/p&gt;
&lt;p&gt;Pinpoint 为每个组件（Component）生成唯一的 Component ID 用于标记组件，为每个 HTTP 请求生成唯一的标识 Request ID 标记请求。在请求执行中 Request ID 通过线程局部变量（ThreadLocal）传递到下游组件，每次调用到一个组件，就使用 (Request ID , Component ID) 组合记录一个 Trace Log。除此之外，Pinpoint 还实时检测请求是否成功，并利用 Failure 字段对请求的成功和失败进行标记。 最后汇总 Trace Log 可获得下表所示的 Trace 数据。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./pinpoint2.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文发表于 2002 年的 CCF B 类会议 DSN，是我看到的第一篇生成唯一的 Request ID，并进行全链路传播的论文，为以后 Trace 的实现提供了思路。但在传统的三层架构的服务架构下，Span 之间的父子关系是比较简单的，论文还未考虑复杂的 Parent-Child Span 的构建。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://ieeexplore.ieee.org/document/1029005&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://ieeexplore.ieee.org/document/1029005&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080002fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;02&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50007_nsdi_x-trace-a-pervasive-network-tracing-frameworkfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;07_NSDI_X-Trace: A Pervasive Network Tracing Framework&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./xtrace.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 现代 Internet 系统通常结合不同的应用程序，并且跨越不同的网络管理域。为了构建在分布式集群的网络链路，X-Trace 论文延续并扩展了 Pinpoint 论文的思路，提出了能够重新构建完整 Trace 的框架。&lt;/p&gt;
&lt;p&gt;X-Trace 的调用链追踪方案是对 Poinpont 思路的扩展，它将 Trace 的 Meta Data 写入到 message 中 (例如，写入到 HTTP 请求的拓展头上)，并沿着请求传播到经过的每个设备上。 与 Poinpont 相比，如下图所示 X-Trace 的 Meta Data 扩展了更多的元素，引入了 Span ID 和 Colletor 地址的概念。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./xtrace2.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;此外，X-Trace 还设计了一个Trace Collector 的框架，将 Trace 的生成与采集解耦。X-Trace 在本地启动一个开放一个 UDP 协议端口的守护进程，应用可以将 Trace 发送到守护进程，并放入到一个队列中，队列的另外一边则将 Trace 发送到缓存或者持久化的数据库中。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./xtrace3.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; X-Trace 发表于 2007 年的 CCF A 类会议 NSDI，论文对 Trace 的 Meta Data 的定义已经初具雏形，Trace Collector 的架构也深深地影响了现今的 Opentelemetry Collector, Jeager Agent 等 Trace Collector。但 X-Trace  还主要注重于 Trace 结构的构建，对时间的开销是忽视的，不能很好地诊断性能问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://www.usenix.org/conference/nsdi-07/x-trace-pervasive-network-tracing-framework&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.usenix.org/conference/nsdi-07/x-trace-pervasive-network-tracing-framework&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080003fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;03&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50010_google_dapper-a-large-scale-distributed-systems-tracing-infrastructurefontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;10_Google_Dapper, a Large-Scale Distributed Systems Tracing Infrastructure&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./dapper.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; Google 网站一个 Web Search 请求可能需要上千台服务器和很多不同开发团队开发的服务去处理，为了帮助理解系统的表现和论证效率，Google 设计和开发了 Dapper 用于观测整个系统的行为。 Dapper 的设计理念与 Pinpoint、 X-Trace 有许多是相通的，Dapper 更注重于在工业应用中的低开销和应用的透明化。&lt;/p&gt;
&lt;p&gt;由于 Google 内部的程序间的通信大多是通过 RPC 完成的，因此 Google 将 Dapper Trace 的预先插桩在 RPC 的框架内，预先定义所有 RPC 调用相关 Span，降低了 Trace 插桩的成本。下图展示了 Dapper Trace 的结构，Trace 由基本单元 Span 组成，一条 Trace 的所有 Span 共享唯一的可标识的 TraceID , 一个 Span 就是带有起止时间戳、RPC 耗时以及应用相关的 annotation。Parent Span 和 Child Span 通过 Parent ID 关联。引入 RPC 耗时将极大提升 Trace 用于根因定位潜力。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./dapper1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt;     此外，为了达到低开销的设计目标，Dapper 还提出对 Trace 的采集进行采样。根据 Dapper 在谷歌的实践经验，对于许多常用的场景，即使对 1/1024 的请求进行采样收集，也能够得到足够的信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CloudWeekly 每周分享与云计算相关论文，相关的论文集被收纳到 github 仓库 &lt;a href=&#34;https://github.com/IntelligentDDS/awesome-papers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/IntelligentDDS/awesome-papers&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>基于 Metrics 的根因定位 (三)：多维下钻</title>
      <link>https://yuxiaoba.github.io/post/log_based_rca_1/</link>
      <pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://yuxiaoba.github.io/post/log_based_rca_1/</guid>
      <description>&lt;p&gt;之前我总结了两种常见的基于 Metric 的根因定位算法 &lt;a href=&#34;https://yuxiaoba.github.io/post/metric_based_rca_1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 Metrics 的根因定位 (一)：故障刻画&lt;/a&gt; 和  &lt;a href=&#34;https://yuxiaoba.github.io/post/metric_based_rca_2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 Metrics 的根因定位 (二)：因果关系图&lt;/a&gt; 。这一次介绍第三种基于 Metric 的根因定位算法: 多维下钻。&lt;/p&gt;
&lt;p&gt;在 SRE 检测到 KPI 发生异常时（如响应成功率下降），还面临一个灵魂拷问：为什么发生异常了？（成功率为什么下降了？），这个时候我们需要增加维的层次，从而可以由粗粒度的数据到细粒度的数据来观察数据。&lt;/p&gt;
&lt;p&gt;例如下表我们发现某服务的当前总的失败请求数目比前一个时间点增加了很多，工程师会进一步挖掘失败请求的属性，比如查看数据中心的元素，发现广州的数据中心存在异常导致的这次故障，这就是一个简单的多维下钻的样例。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;数据中心&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;前一时间点失败请求数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;当前时间失败请求数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;差异&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;广州&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1000&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;990&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;上海&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;北京&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;合计&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;25&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1016&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;991&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;center-font-color0080001fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;01&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50014_nsdi_adtributor-revenue-debugging-in-advertising-systemsfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;14_NSDI_Adtributor: Revenue Debugging in Advertising Systems&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./adtributor.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 论文针对广告营收领域的 revenue debugging问题，将多维根因分析问题分解为多个单维根因分析问题，提出了的 Adtributor 算法，并分别针对量值与率值两类指标进行多维度的根因分析。整体思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;利用 ARMA 模型进行异常检测。根据8周的历史数据，考虑到正常的时间和星期的波动，生成一个基于模型的测量值预测。然后，将实际值与预测值进行比较：当一个测量值的实际值与预测值有明显差异时，将产生一个异常警报。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算每个维度下每个元素的 explanatory power （单个元素预测值与实际值的差异和整个维度预测值与实际值差异的比值，论文公式 4） 与 surprise 值（可直观理解为预测值与实际值变化的程度，论文公式 5），定位出每个维度下的异常元素集合，最后根据每个维度总的 surprise  值大小汇总输出根因集合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./adtributor1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; Microsoft 2014 年发表在 NSDI （CCF A）上的论文，论文可以说是基于 Metrics 的多维下钻分析的开山之作，论文在 Mcirosoft 实际落地，可解释性比较强，后面的多维下钻的工作也大多在其基础之上进行创新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://www.usenix.org/system/files/conference/nsdi14/nsdi14-paper-bhagwan.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.usenix.org/system/files/conference/nsdi14/nsdi14-paper-bhagwan.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080002fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;02&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50016_icse_idice-problem-identification-for-emerging-issuesfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;16_ICSE_iDice: Problem Identification for Emerging Issues&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./idice.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 软件在发布时一般会有很多分类属性（例如版本号，地域，操作平台等），如果发布有异常，用户通过会上报一些反馈的 Issue，此时需要运维工程师能够快速定位究竟是哪些属性造成了 Issue 的上升，提升响应的速度。文章以 Issue 的上升作为告警，通过分析一个时间窗口内 Issue 的属性的组合，找出最有可能导致 Issue 上升的最小属性组合。在搜索空间过大的问题上论文使用了启发式的三个剪枝策略来应对：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Impact based Pruning：一个有用的属性必须引起较大数量变化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change Detection based Pruning: 一个有用的属性组合必须在时间点上符合变化特征&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Isolation Power based Prunning: 合并多余属性组合&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./idice1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; MSRA 林庆维研究员 2016 年发表在 ICSE（CCF A）的论文。论文针对性地处理了用户反馈 Issue 的维度下钻，并在微软落地，剪枝的策略值得学习。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;http://hongyujohn.github.io/iDice.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://hongyujohn.github.io/iDice.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080003fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;03&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50020_ase_impaptr-a-tool-for-identifying-the-clues-to-online-service-anomaliesfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;20_ASE_ImpAPTr: A Tool For Identifying The Clues To Online Service Anomalies&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./impaptr.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 论文是一个广度优先的多维下钻根因定位算法，ImpAPTr，整体思路可分为以下四个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;根据维度组合创建包含根结点和子结点的元素树，如下图所示；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用广度优先遍历算法，删除冗余元素和影响系数 （Impact Factor）相反的元素（论文公式3）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算每个维度组合的贡献度 （Contribution Power，连续两个时间段的影响系数差值，论文公式4）和差异系数 （Diversity Factor， 两个连续时间段内的成功率指标变化程度， 论文公式 5） ；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算每个维度组合 Contribution Power 和 Diversity Factor 的排名之和 ，选取前 n 个维度组合作为成功率下跌的根因线索。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./impaptr1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文是南京大学与美团合作发表在 ASE 2020 上的一篇短文。与 Adtributor  只考虑单个维度不同，ImpAPTr 考虑了多个维度，且构建出维度之间的关系图，通过在图上做广度优先搜索进行根因定位。美团实际落地算法的总结。方法在根因的属性数量不多以及单根因的时候效果应该会比较好。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://dl.acm.org/doi/10.1145/3324884.3415301&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dl.acm.org/doi/10.1145/3324884.3415301&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码链接：&lt;a href=&#34;https://github.com/wanghaoUp/ImpAPTr&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/wanghaoUp/ImpAPTr&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CloudWeekly 每周分享与云计算相关论文，相关的论文集被收纳到 github 仓库 &lt;a href=&#34;https://github.com/IntelligentDDS/awesome-papers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/IntelligentDDS/awesome-papers&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>基于 Metrics 的根因定位 (三)：多维下钻</title>
      <link>https://yuxiaoba.github.io/post/metric_based_rca_3/</link>
      <pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://yuxiaoba.github.io/post/metric_based_rca_3/</guid>
      <description>&lt;p&gt;之前我总结了两种常见的基于 Metric 的根因定位算法 &lt;a href=&#34;https://yuxiaoba.github.io/post/metric_based_rca_1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 Metrics 的根因定位 (一)：故障刻画&lt;/a&gt; 和  &lt;a href=&#34;https://yuxiaoba.github.io/post/metric_based_rca_2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 Metrics 的根因定位 (二)：因果关系图&lt;/a&gt; 。这一次介绍第三种基于 Metric 的根因定位算法: 多维下钻。&lt;/p&gt;
&lt;p&gt;在 SRE 检测到 KPI 发生异常时（如响应成功率下降），还面临一个灵魂拷问：为什么发生异常了？（成功率为什么下降了？），这个时候我们需要增加维的层次，从而可以由粗粒度的数据到细粒度的数据来观察数据。&lt;/p&gt;
&lt;p&gt;例如下表我们发现某服务的当前总的失败请求数目比前一个时间点增加了很多，工程师会进一步挖掘失败请求的属性，比如查看数据中心的元素，发现广州的数据中心存在异常导致的这次故障，这就是一个简单的多维下钻的样例。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;数据中心&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;前一时间点失败请求数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;当前时间失败请求数&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;差异&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;广州&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1000&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;990&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;上海&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;北京&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;合计&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;25&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1016&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;991&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;center-font-color0080001fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;01&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50014_nsdi_adtributor-revenue-debugging-in-advertising-systemsfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;14_NSDI_Adtributor: Revenue Debugging in Advertising Systems&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./adtributor.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 论文针对广告营收领域的 revenue debugging问题，将多维根因分析问题分解为多个单维根因分析问题，提出了的 Adtributor 算法，并分别针对量值与率值两类指标进行多维度的根因分析。整体思路如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;利用 ARMA 模型进行异常检测。根据8周的历史数据，考虑到正常的时间和星期的波动，生成一个基于模型的测量值预测。然后，将实际值与预测值进行比较：当一个测量值的实际值与预测值有明显差异时，将产生一个异常警报。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算每个维度下每个元素的 explanatory power （单个元素预测值与实际值的差异和整个维度预测值与实际值差异的比值，论文公式 4） 与 surprise 值（可直观理解为预测值与实际值变化的程度，论文公式 5），定位出每个维度下的异常元素集合，最后根据每个维度总的 surprise  值大小汇总输出根因集合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./adtributor1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; Microsoft 2014 年发表在 NSDI （CCF A）上的论文，论文可以说是基于 Metrics 的多维下钻分析的开山之作，论文在 Mcirosoft 实际落地，可解释性比较强，后面的多维下钻的工作也大多在其基础之上进行创新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://www.usenix.org/system/files/conference/nsdi14/nsdi14-paper-bhagwan.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.usenix.org/system/files/conference/nsdi14/nsdi14-paper-bhagwan.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080002fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;02&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50016_icse_idice-problem-identification-for-emerging-issuesfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;16_ICSE_iDice: Problem Identification for Emerging Issues&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./idice.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 软件在发布时一般会有很多分类属性（例如版本号，地域，操作平台等），如果发布有异常，用户通过会上报一些反馈的 Issue，此时需要运维工程师能够快速定位究竟是哪些属性造成了 Issue 的上升，提升响应的速度。文章以 Issue 的上升作为告警，通过分析一个时间窗口内 Issue 的属性的组合，找出最有可能导致 Issue 上升的最小属性组合。在搜索空间过大的问题上论文使用了启发式的三个剪枝策略来应对：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Impact based Pruning：一个有用的属性必须引起较大数量变化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change Detection based Pruning: 一个有用的属性组合必须在时间点上符合变化特征&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Isolation Power based Prunning: 合并多余属性组合&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./idice1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; MSRA 林庆维研究员 2016 年发表在 ICSE（CCF A）的论文。论文针对性地处理了用户反馈 Issue 的维度下钻，并在微软落地，剪枝的策略值得学习。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;http://hongyujohn.github.io/iDice.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://hongyujohn.github.io/iDice.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080003fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;03&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50020_ase_impaptr-a-tool-for-identifying-the-clues-to-online-service-anomaliesfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;20_ASE_ImpAPTr: A Tool For Identifying The Clues To Online Service Anomalies&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./impaptr.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 论文是一个广度优先的多维下钻根因定位算法，ImpAPTr，整体思路可分为以下四个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;根据维度组合创建包含根结点和子结点的元素树，如下图所示；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用广度优先遍历算法，删除冗余元素和影响系数 （Impact Factor）相反的元素（论文公式3）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算每个维度组合的贡献度 （Contribution Power，连续两个时间段的影响系数差值，论文公式4）和差异系数 （Diversity Factor， 两个连续时间段内的成功率指标变化程度， 论文公式 5） ；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算每个维度组合 Contribution Power 和 Diversity Factor 的排名之和 ，选取前 n 个维度组合作为成功率下跌的根因线索。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./impaptr1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文是南京大学与美团合作发表在 ASE 2020 上的一篇短文。与 Adtributor  只考虑单个维度不同，ImpAPTr 考虑了多个维度，且构建出维度之间的关系图，通过在图上做广度优先搜索进行根因定位。美团实际落地算法的总结。方法在根因的属性数量不多以及单根因的时候效果应该会比较好。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://dl.acm.org/doi/10.1145/3324884.3415301&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://dl.acm.org/doi/10.1145/3324884.3415301&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码链接：&lt;a href=&#34;https://github.com/wanghaoUp/ImpAPTr&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/wanghaoUp/ImpAPTr&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CloudWeekly 每周分享与云计算相关论文，相关的论文集被收纳到 github 仓库 &lt;a href=&#34;https://github.com/IntelligentDDS/awesome-papers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/IntelligentDDS/awesome-papers&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>异常变更识别(一)</title>
      <link>https://yuxiaoba.github.io/post/change_1/</link>
      <pubDate>Fri, 30 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://yuxiaoba.github.io/post/change_1/</guid>
      <description>&lt;p&gt;微服务架构和CI/CD的出现让现代应用快速和频繁的开发和发布新的特性成为可能，但是频繁的代码和配置变更为系统引入了更多的不稳定因素。根据 Google SRE 书的描述有 70% 的 incident 都是由变更导致的，因此在程序灰度变更时及时的发现异常变更，尽快地采取 rollback 的策略是非常重要的。本文介绍三个学术界和工业界前沿的异常变更识别方法。&lt;/p&gt;
&lt;h2 id=&#34;center-font-color0080001fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;01&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50021_fse_identifying-bad-software-changes-via-multimodal-anomaly-detection-for-online-service-systemsfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;21_FSE_Identifying Bad Software Changes via Multimodal Anomaly Detection for Online Service Systems&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./scwarn.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 随着微服务架构和 CICD 的普遍应用以及业务的压力，现代应用的变更越来越频繁。频繁的变更可以带来业务的快速迭代，但也增大了系统发生故障的概率。这篇论文首先对一个银行系统的历史故障进行了分析，然后得出 50 % 的故障是由于变更导致的，并且不同的变更反应在不同的 Metric 和 Log 上。因此作者提出将 Log 时序化，并通过融合Metric 和 Log 训练一个 LSTM 模型用于异常检测，如果LSTM模型预测值与实际值相差较大则会进行告警。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./scwarn1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 清华大学裴丹老师团队和天津大学陈俊洁老师合作的论文，论文发表在 CCF A 类会议 FSE 2021 上，论文从结构和语言上都非常值得学习。但是不是很能够理解变更系统引入日志，因为很有可能程序员在变更的时候就会打印新的日志，那这样也会被认定为程序出现了新的日志从而产生告警。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://netman.aiops.org/wp-content/uploads/2021/09/SCWarn.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://netman.aiops.org/wp-content/uploads/2021/09/SCWarn.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码链接：&lt;a href=&#34;https://github.com/FSEwork/SCWarn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/FSEwork/SCWarn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080002fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;02&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50015_conext_rapid-and-robust-impact-assessment-of-software-changes-in-large-internet-based-servicesfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;15_CoNEXT_Rapid and Robust Impact Assessment of Software Changes in Large Internet-based Services&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./funnel.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 当服务更新后，论文首先获得已更新服务实例、changed 服务以及 affected 服务的 KPI，然后基于一个改进版的 Singular Spectrum Transform 检测出异常的 KPI 。如果changed 服务发生性能变化，则基于 difference-in-difference (DiD) 检测属于changed 服务的已更新的服务实例（tinstance）和未更新服务实例（cinstance）的KPI 是否存在差异，如果存在差异可以直观的理解为更新导致他们的差异。如果是上游的 affected 服务的 KPI 发生变化，那则将服务更新前的 KPI 视为（cservice）和更新后的 KPI 视为（tservice），然后同样基于 DiD 检测他们是否有显著性的差异，如果存在差异则认为 affected 服务的变化是由于下游服务更新导致的。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./funnel1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文是南开大学张圣林老师在读博士时在百度的工作，发表在 CCF B 类会议 CoNEXT 2015 上，论文只判断单个变更是否异常，如果上下游都有变更，很难进行处理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://conferences2.sigcomm.org/co-next/2015/img/papers/conext15-final2.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://conferences2.sigcomm.org/co-next/2015/img/papers/conext15-final2.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080003fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;03&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50020_nsdi_gandalf-an-intelligent-end-to-end-analytics-service-for-safe-deployment-in-large-scale-cloud-infrastructurefontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;20_NSDI_Gandalf: An Intelligent, End-To-End Analytics Service for Safe Deployment in Large-Scale Cloud Infrastructure&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./gandalf.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 当程序变更后，论文先统计失败的日志事件出现的次数，然后基于 Holt-Winters forecasting 检测出现异常的日志事件并判定为 Error。 对每一个 Error ，Gandalf 会计算它与变更的时空相关性。时间相关性基于假设“对一个变更，如果一个故障发生时间与变更的时间越接近，他们更相关”。空间相关性基于假设“在变更期间，未变更节点中发生的故障百分比越高，变更和故障之间的因果关系越低”。最后对于每个变更的得分，Gandalf 通过 Gaussian discriminant classifier 判断是否要继续变更还是 rollback。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./gandalf1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; Gandalf 是 MicroSoft Azure 发表在 CCF A 类会议 NSDI 的论文，应该是有实际落地在用的。论文在投票阶段的描述应该是写错了，导致很难理解投票与反对的关系，建议可以看一下他的 presentation 来帮助理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://www.usenix.org/conference/nsdi20/presentation/li&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.usenix.org/conference/nsdi20/presentation/li&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CloudWeekly 每周分享与云计算相关论文，相关的论文集被收纳到 github 仓库 &lt;a href=&#34;https://github.com/IntelligentDDS/awesome-papers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/IntelligentDDS/awesome-papers&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DDS 第一手消息（一）</title>
      <link>https://yuxiaoba.github.io/post/recent_paper1/</link>
      <pubDate>Fri, 09 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://yuxiaoba.github.io/post/recent_paper1/</guid>
      <description>&lt;p&gt;实验室最近在 ASE2022，ISSRE2022, ICSOC2022, ICWS2022 等会议上，都有斩获，下面简单的分享一下我们的工作。&lt;/p&gt;
&lt;h2 id=&#34;center-font-color0080001fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;01&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50022_ase_graph-based-incident-extraction-and-diagnosis-in-large-scale-online-systemsfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;22_ASE_Graph based Incident Extraction and Diagnosis in Large-Scale Online Systems&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./gied1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 在大规模微服务系统中，一个可用性的故障可能会因级联效应导致多个上游服务发生异常，这导致难以定位出真正的根因。为了解决这个问题，本文首先将 KPI 与前一天的 KPI 值进行对比对 KPI 进行异常检测，并基于 DBSCAN 和链路图抽取出与被故障影响的异常子图。接着将异常子图及其节点的特征输入到图神经网络中判断是否异常。如果异常，则在此异常子图上利用 Pagerank 定位出根因。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./gied.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文发表在 CCF A 类会议 ASE 2022 上，论文比较详细地介绍了当前微信内部基于指标和服务依赖图的根因定位算法，久经考验，非常值得落地学习。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://yuxiaoba.github.io/publication/gied22/gied22.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuxiaoba.github.io/publication/gied22/gied22.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码链接：&lt;a href=&#34;https://github.com/IntelligentDDS/GIED&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/IntelligentDDS/GIED&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080002fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;02&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50022_issre_going-through-the-life-cycle-of-faults-in-cloudsguidelines-on-fault-handlingfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;22_ISSRE_Going through the Life Cycle of Faults in Clouds:Guidelines on Fault Handling&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./incident1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 即便是当前最先进的云平台，小范围的可用性故障依旧是层出不穷。云厂商在故障发生后，通常会公开自己对故障的事后分析来给用户一个解释。在本文中，我们收集并格式化了 354 个来自 AWS，Azure，Google 公开的故障的事后调查（incident）。在此数据集之上，我们从故障的生命周期：故障发生，故障检测，故障定位，故障修复四个方面对这些 incident 进行了定量和定性的研究，并获得了 10 个重要的发现。最后我们还基于这些发现指导当前云计算平台的智能运维，混沌工程和可观测性的研究。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./incident.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文发表在 CCF B 类会议 ISSRE 2022 上，采集这 300 多个 incident 的经历真的不堪回首，甚至还为我在微信实习的第一个工作打下了基础。在 rebuttal 的时候还出了突发情况，还好最后被录用了，不用再继续更新数据集了。当时我在读 Google SRE 书的时候突然想引用了几个名人名言，还挺有意思的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://yuxiaoba.github.io/publication/incident22/incident22.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuxiaoba.github.io/publication/incident22/incident22.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码链接：&lt;a href=&#34;https://github.com/IntelligentDDS/Post-mortems-Analysis&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/IntelligentDDS/Post-mortems-Analysis&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080003fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;03&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50022_icsoc_microsketch-lightweight-and-adaptive-sketch-based-performance-issue-detection-and-localization-in-microservice-systemsfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;22_ICSOC_MicroSketch: Lightweight and Adaptive Sketch based Performance Issue Detection and Localization in Microservice Systems&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./microsketch1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; Trace 是可观测性的重要组成部分，但是基于 Trace 的异常检测和根因定位算法一直受制于对每条 Trace 分析带来的巨大开销。本文借鉴了网络通信中常用的 Sketch 的思想，首先基于 Sketch 计算出每个调用对的百分位数延迟，然后所有调用对的延迟输入到随机砍伐森林 (Robust Random Cut Forest) 中检测出异常的调用对，最后根据投票机制定位出根因。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./microsketch.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文发表在 CCF B 类会议 ICSOC 2022 上，考虑到大规模的生产系统上遍历分析每一条 Trace 的成本，把 Trace 指标化是当前工业界利用 Trace 进行分析的主要方式。本文提出了基于 Sketch 的轻量级 Trace 指标化方案，与遍历每条 Trace 进行分析的 Microrank 相比，速度提升明显。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://yuxiaoba.github.io/publication/microsketch22/microsketch22.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuxiaoba.github.io/publication/microsketch22/microsketch22.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080004fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;04&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50022_icws_ts-invarnet-anomaly-detection-and-localization-based-on-tempo-spatial-kpi-invariants-in-distributed-servicesfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;22_ICWS_TS-InvarNet: Anomaly Detection and Localization based on Tempo-spatial KPI Invariants in Distributed Services&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./tsnet1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 在大规模的分布式系统正常运行中，某两个 KPI 之间可能存在某种稳定的关系。例如，上下游服务因流量的一致性可能 CPU 利用率的变化存在相似的变化关系。我们把这种稳定的关系称为不变量。本文致力于在系统正常运行阶段挖掘出不同 KPI 之间的不变量关系，在系统发生故障后通过检测不变量是否被破坏来进行异常检测和根因定位。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./tsnet.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论:&lt;/strong&gt; 当前的基于深度学习的异常检测算法通常可解释性比较差，我们提出的基于时空不变量的方法有较强的可解释性，易于工程师理解系统的变化。下图中展示了当故障发生时，不同节点的 KPI 之间不变量的变化的例子，非常容易理解。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./tsnet2.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://yuxiaoba.github.io/publication/tsinvarnet22/tsInvarNet22.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://yuxiaoba.github.io/publication/tsinvarnet22/tsInvarNet22.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CloudWeekly 每周分享与云计算相关论文，相关的论文集被收纳到 github 仓库 &lt;a href=&#34;https://github.com/IntelligentDDS/awesome-papers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/IntelligentDDS/awesome-papers&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>基于 Metrics 的根因定位 (二)：因果关系图</title>
      <link>https://yuxiaoba.github.io/post/metric_based_rca_2/</link>
      <pubDate>Sun, 04 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://yuxiaoba.github.io/post/metric_based_rca_2/</guid>
      <description>&lt;p&gt;上篇文章&lt;a href=&#34;https://yuxiaoba.github.io/post/metric_based_rca_1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;基于 Metrics 的根因定位 (一)：故障刻画&lt;/a&gt; 介绍了使用故障刻画思想定位根因的几种算法。除故障刻画外，还有另外一种根因定位的思想是通过 Metrics 之间的依赖关系构建出因果关系图，然后基于相关性或随机游走算法在图上游走从而定位出根因。下面简要介绍典型的几个 Micro.X 算法。&lt;/p&gt;
&lt;h2 id=&#34;center-font-color0080001fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;01&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50018_icsoc_microscope-pinpoint-the-abnormal-services-with-causal-graphs-in-micro-service-environmentsfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;18_ICSOC_Microscope: Pinpoint the Abnormal Services with Causal Graphs in Micro-service Environments&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./microscope1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 在不进行源代码进行插桩的情况下，Microscope 通过拦截网络连接信息和指标之间的相关性构建出微服务之间的因果关系图。在根因定位被触发时，Microscope 从前端对因果关系图进行遍历，找到因果关系图每个分支中最深的 SLO 异常服务并判定为根因候选。最后计算根因候选与前端服务的相关性为每个根因候选赋予得分。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./microscope.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文是我导师来了中大以后组内的第一篇论文,发布在 CCF B 类会议 ICSOC 上。第一作者的师兄去了外交部，现在在非洲为国奋斗。论文的主要贡献放在因果关系图的构建，根因的推断是比较简单的深度优先搜索和根节点的相关性计算。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://link.springer.com/chapter/10.1007/978-3-030-03596-9_1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://link.springer.com/chapter/10.1007/978-3-030-03596-9_1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080002fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;02&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50020_microrca-root-cause-localization-of-performance-issues-in-microservicesfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;20_MicroRCA: Root Cause Localization of Performance Issues in Microservices&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./microrca1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; MicroRCA 首先构建一个包含服务调用路径对应主机的属性图。在异常发生时，MicroRCA 通过判断服务之间的边的响应延迟是否异常提取异常子图。然后通过对子图进行加权计算连接节点之间的相似度，接着使用异常服务节点的响应时间与其容器资源利用率之间的最大相关系数来调整服务异常的分数，最后使用 PageRank 算法进行定位根因。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./microrca.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文通过构建因果关系图，然后通过对图上的节点和边赋予权重进行 PageRank 计算，是一个通用的根因定位思路。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://hal.inria.fr/hal-02441640/document&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://hal.inria.fr/hal-02441640/document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码链接：&lt;a href=&#34;https://github.com/elastisys/MicroRCA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/elastisys/MicroRCA&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080003fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;03&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50021_microdiag-fine-grained-performance-diagnosis-for-microservice-systemsfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;21_MicroDiag: Fine-grained Performance Diagnosis for Microservice Systems&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./microdiag1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; MicroDiag 首先构建不同指标类型之间的异常传播依赖关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对资源类指标（如 CPU）传播, MicroDiag 采用 SCM（Structural Causal Model）推断异常的传播方向&lt;/li&gt;
&lt;li&gt;对业务指标传播（如 Latency）MicroDiag 先用 Istio 获得服务依赖图，然后根据服务依赖图的逆向推断传播方向&lt;/li&gt;
&lt;li&gt;通过资源类和业务类指标传播, MicroDiag 采用 Granger causality tests 推断异常的传播方向&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接着 MicroDiag 通过皮尔逊相关系数计算指标间的相似性来判断异常传播的概率，在归一化权重后通过 PageRank 直接计算图中节点的重要性给出节点排序。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./microdiag.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文发表在 ICSE 2021 的 Workshop 上，对不同种类的资源采用不同的因果推断异常传播的方向值得学习。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://hal.inria.fr/hal-03155797/document&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://hal.inria.fr/hal-03155797/document&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color0080004fontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;04&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50021_microhecl-high-efﬁcient-root-cause-localization-in-large-scale-microservice-systemsfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;21_MicroHECL: High-Efﬁcient Root Cause Localization in Large-Scale Microservice Systems&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./microhecl1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt;  MicroHECL 首先根据根据最近30分钟的服务调用关系构造出服务依赖图，然后通过划分三个异常类型，构建出异常的传播图，最后根据异常传播图找到最深的节点作为根因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对性能故障，MicroHECL 采用 OC-SVM（one class support vector machine）以响应延迟的特征作为输入，判断是否存在性能故障。如果存在性能故障，故障传播从下游传播到上游&lt;/li&gt;
&lt;li&gt;对可靠性故障，MicroHECL 采用随机森林以请求错误率的特征作为输入，判断是否存在可靠性故障。如果存在可靠性故障，故障传播从下游传播到上游&lt;/li&gt;
&lt;li&gt;流量异常故障，MicroHECL 采用3-sigma 规则检测 QPS 的波动，判断是否存在流量异常故障。如果存在流量异常故障，故障传播从上游传播到下游&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后论文还提出了一个异常传播图剪枝的策略提高分析效率&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./microhecl.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 本文是复旦大学彭鑫老师团队与阿里巴巴合作的论文，论文发表在 ICSE 2021 的 Workshop 上，论文预先对不同种类的异常进行分类，然后根据不同的传播方向分别构造异常传播图的思路值得学习。论文在阿里巴巴的数据上上取得 top3 为 68% 的准确率。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://arxiv.org/pdf/2103.01782.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://arxiv.org/pdf/2103.01782.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CloudWeekly 每周分享与云计算相关论文，相关的论文集被收纳到 github 仓库 &lt;a href=&#34;https://github.com/IntelligentDDS/awesome-papers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/IntelligentDDS/awesome-papers&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>基于 Metrics 的根因定位 (一)：故障刻画</title>
      <link>https://yuxiaoba.github.io/post/metric_based_rca_1/</link>
      <pubDate>Sat, 03 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://yuxiaoba.github.io/post/metric_based_rca_1/</guid>
      <description>&lt;p&gt;故障刻画是指通过提取历史的故障发生时不同 Metric 变化的特征，挖掘出不同种类故障发生时 Metric 变化的特征集合。在运行时阶段，可通过匹配特征集合定位到具体的故障种类。&lt;/p&gt;
&lt;p&gt;例如：CPU 竞争的故障的指标变化特征是 {&amp;ldquo;CPU 利用率升高&amp;rdquo;, &amp;ldquo;响应延迟升高&amp;rdquo;}。那么当在线程序出现  {&amp;ldquo;CPU 利用率升高&amp;rdquo;, &amp;ldquo;响应延迟升高&amp;rdquo;} 的情况时可推断为 CPU 竞争的故障。&lt;/p&gt;
&lt;h2 id=&#34;center-font-color00800u01ufontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;&lt;u&gt;01&lt;/u&gt;&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50022_fse_actionable-and-interpretable-fault-localization-for-recurring-failures-in-online-service-systemfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;22_FSE_Actionable and Interpretable Fault Localization for Recurring Failures in Online Service System&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./dejavu1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; Dejavu 是一种通过对故障进行刻画找到每种故障对应的特征，从而在故障重复发生时快速进行根因定位的方法。Dejavu 利用基于 gated recurrent unit (GRU) recurrent neural networks 构建的特征提取器统一表达故障故障单元（failure class）。然后根据 Trace 和 CMDB 构建的 failure dependency graph（FDG）。接着基于 graph attention networks (GAT) 算法对 FDG 图上的每个故障单元计算聚合的特征。最后在基于 dense neural network 为每个故障单元计算出故障的得分，得分最高的为根因故障。此外，Dejavu 还提供了故障的可解释算法用于向 SRE 解释故障的根因。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./dejavu.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文是清华大学裴丹老师团队在 CCF A类会议 FSE 上发表。论文主要针对故障重复发生的场景，需要大量的标签，且无法很好地处理新的故障。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;https://arxiv.org/abs/2207.09021https://arxiv.org/abs/2207.09021&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://arxiv.org/abs/2207.09021&lt;/a&gt;
代码链接：&lt;a href=&#34;https://github.com/NetManAIOps/DejaVu&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/NetManAIOps/DejaVu&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color00800u02ufontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;&lt;u&gt;02&lt;/u&gt;&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50020_vldb_diagnosing-root-causes-of-intermittent-slow-queries-in-cloud-databasesfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;20_VLDB_Diagnosing Root Causes of Intermittent Slow Queries in Cloud Databases&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./isquad1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; MicroRCA 首先构建一个包含服务调用路径对应主机的属性图。在异常发生时，MicroRCA 通过判断服务之间的边的响应延迟是否异常提取异常子图。然后通过对子图进行加权计算连接节点之间的相似度，接着使用异常服务节点的响应时间与其容器资源利用率之间的最大相关系数来调整服务异常的分数，最后使用 PageRank 算法进行定位根因。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./isquad.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;论文定义了四种值得参考的异常类型&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./isquad2.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt;  MSRA 马明华博士在阿里巴巴李飞飞博士团队访问时发表在 CCF A类会议 VLDB 上的论文。文章是一篇优秀的故障刻画文章。创新性的提出利用指标的类型来增加更多的线索，方法也可以用于指标的压缩。但是要获得 Level Shift Up 的类型需要长时间的数据采集，不能实现及时的根因定位。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;http://www.vldb.org/pvldb/vol13/p1176-ma.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.vldb.org/pvldb/vol13/p1176-ma.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码链接：&lt;a href=&#34;https://github.com/NetManAIOps/DejaVu/blob/master/iSQUAD/iSQ.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/NetManAIOps/DejaVu/blob/master/iSQUAD/iSQ.py&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;center-font-color00800u03ufontcenter&#34;&gt;&lt;center&gt; &lt;font color=#00800&gt;&lt;u&gt;03&lt;/u&gt;&lt;/font&gt;&lt;/center&gt;&lt;/h2&gt;
&lt;h3 id=&#34;centerfont-colorffa50021_issre_identifying-root-cause-metrics-for-incident-diagnosis-in-online-service-systemsfontcenter&#34;&gt;&lt;center&gt;&lt;font color=#FFA500&gt;21_ISSRE_Identifying Root-Cause Metrics for Incident Diagnosis in Online Service Systems&lt;/font&gt;&lt;/center&gt;&lt;/h3&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./issre21.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文简介:&lt;/strong&gt; 论文从大规模的生产系统中总结出 13 种典型的异常模式。然后提出了一个有监督的根因定位算法 PatternMatcher. PatternMatcher采用双样本假设检验作为粗粒度的异常检测算法，筛选出在该事件发生时表现正常的指标，从而大大减少搜索空间。之后，利用主动学习对历史故障进行标签，训练出一种基于一维CNN的异常模式分类方法，过滤掉那些工程师不关心的异常模式。最后利用 p-value 方法对每个指标计算得分并排序。&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./issre21fault.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;论文中总结的典型的指标异常模式：&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;./issre21p.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人评论：&lt;/strong&gt; 论文是清华大学裴丹老师团队的论文，论文总结出的典型的指标异常模式是很值得学习的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;论文链接：&lt;a href=&#34;http://netman.aiops.org/wp-content/uploads/2021/10/wch_ISSRE-1.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://netman.aiops.org/wp-content/uploads/2021/10/wch_ISSRE-1.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CloudWeekly 每周分享与云计算相关论文，相关的论文集被收纳到 github 仓库 &lt;a href=&#34;https://github.com/IntelligentDDS/awesome-papers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/IntelligentDDS/awesome-papers&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
